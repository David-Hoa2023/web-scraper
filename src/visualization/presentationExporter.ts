/**
 * Presentation Exporter
 * Exports slide presentations to PPTX and PDF formats
 */

import pptxgen from 'pptxgenjs';
import { jsPDF } from 'jspdf';
import type {
  SlideData,
  TitleSlideContent,
  MetricsSlideContent,
  ChartSlideContent,
  TableSlideContent,
  SummarySlideContent,
} from './chartSelector';

// --- Types ---

export interface ExportOptions {
  filename?: string;
  author?: string;
  title?: string;
  subject?: string;
  company?: string;
}

export interface ExportResult {
  success: boolean;
  filename: string;
  format: 'pptx' | 'pdf';
  error?: string;
}

// --- Color Definitions ---

const COLORS = {
  background: '16213e',
  backgroundDark: '0f0f23',
  cardBackground: '1e2a4a',
  text: 'eeeeee',
  textSecondary: '888888',
  accent: '667eea',
  accentGradient: '764ba2',
  good: '22c55e',
  warning: 'eab308',
  critical: 'ef4444',
  chart: ['8884d8', '82ca9d', 'ffc658', 'ff7300', '0088fe', '00C49F'],
};

// --- PPTX Export ---

/**
 * Export slides to PPTX format
 */
export async function exportToPptx(
  slides: SlideData[],
  options: ExportOptions = {}
): Promise<ExportResult> {
  const {
    filename = 'presentation',
    author = 'Web Scraper Pro',
    title = 'Data Analysis Report',
    subject = 'Scraped Data Visualization',
    company = '',
  } = options;

  try {
    const pptx = new pptxgen();

    // Set presentation properties
    pptx.author = author;
    pptx.title = title;
    pptx.subject = subject;
    pptx.company = company;

    // Define master slide layout
    pptx.defineSlideMaster({
      title: 'MASTER_SLIDE',
      background: { color: COLORS.background },
      objects: [
        // Footer
        {
          text: {
            text: 'Generated by Web Scraper Pro',
            options: {
              x: 0.5,
              y: 5.3,
              w: '90%',
              h: 0.3,
              fontSize: 8,
              color: COLORS.textSecondary,
              align: 'left',
            },
          },
        },
      ],
    });

    // Generate each slide
    for (const slideData of slides) {
      const slide = pptx.addSlide({ masterName: 'MASTER_SLIDE' });

      switch (slideData.type) {
        case 'title':
          addTitleSlidePptx(slide, slideData.content as TitleSlideContent);
          break;
        case 'metrics':
          addMetricsSlidePptx(slide, slideData.content as MetricsSlideContent);
          break;
        case 'chart':
          addChartSlidePptx(slide, slideData.content as ChartSlideContent, slideData.title, slideData.subtitle);
          break;
        case 'table':
          addTableSlidePptx(slide, slideData.content as TableSlideContent, slideData.title);
          break;
        case 'summary':
          addSummarySlidePptx(slide, slideData.content as SummarySlideContent);
          break;
      }
    }

    // Save the file
    const finalFilename = `${filename}.pptx`;
    await pptx.writeFile({ fileName: finalFilename });

    return {
      success: true,
      filename: finalFilename,
      format: 'pptx',
    };
  } catch (error) {
    return {
      success: false,
      filename: '',
      format: 'pptx',
      error: error instanceof Error ? error.message : 'Unknown error during PPTX export',
    };
  }
}

/**
 * Add title slide to PPTX
 */
function addTitleSlidePptx(slide: pptxgen.Slide, content: TitleSlideContent): void {
  // Main title
  slide.addText(content.mainTitle, {
    x: 0.5,
    y: 1.8,
    w: '90%',
    h: 1,
    fontSize: 44,
    fontFace: 'Arial',
    color: COLORS.accent,
    bold: true,
    align: 'center',
  });

  // Subtitle
  slide.addText(content.subtitle, {
    x: 0.5,
    y: 2.9,
    w: '90%',
    h: 0.6,
    fontSize: 20,
    fontFace: 'Arial',
    color: COLORS.textSecondary,
    align: 'center',
  });

  // Date and record count
  slide.addText(`${content.date}  |  ${content.recordCount.toLocaleString()} records`, {
    x: 0.5,
    y: 3.8,
    w: '90%',
    h: 0.4,
    fontSize: 14,
    fontFace: 'Arial',
    color: COLORS.textSecondary,
    align: 'center',
  });
}

/**
 * Add metrics slide to PPTX
 */
function addMetricsSlidePptx(slide: pptxgen.Slide, content: MetricsSlideContent): void {
  // Title
  slide.addText('Data Overview', {
    x: 0.5,
    y: 0.3,
    w: '90%',
    h: 0.6,
    fontSize: 28,
    fontFace: 'Arial',
    color: COLORS.text,
    bold: true,
  });

  // Metrics grid
  const metrics = content.metrics;
  const cols = Math.min(metrics.length, 5);
  const cardWidth = 1.8;
  const cardHeight = 1.2;
  const startX = (10 - (cols * cardWidth + (cols - 1) * 0.2)) / 2;

  metrics.forEach((metric, index) => {
    const x = startX + (index % cols) * (cardWidth + 0.2);
    const y = 1.3 + Math.floor(index / cols) * (cardHeight + 0.2);

    const statusColor = metric.status === 'good' ? COLORS.good :
                       metric.status === 'warning' ? COLORS.warning :
                       metric.status === 'critical' ? COLORS.critical : COLORS.text;

    // Card background
    slide.addShape('rect', {
      x,
      y,
      w: cardWidth,
      h: cardHeight,
      fill: { color: COLORS.cardBackground },
      line: { color: statusColor, width: 2, dashType: 'solid' },
    });

    // Value
    slide.addText(String(metric.value), {
      x,
      y: y + 0.2,
      w: cardWidth,
      h: 0.5,
      fontSize: 24,
      fontFace: 'Arial',
      color: statusColor,
      bold: true,
      align: 'center',
    });

    // Label
    slide.addText(metric.label, {
      x,
      y: y + 0.7,
      w: cardWidth,
      h: 0.35,
      fontSize: 10,
      fontFace: 'Arial',
      color: COLORS.textSecondary,
      align: 'center',
    });
  });
}

/**
 * Add chart slide to PPTX
 */
function addChartSlidePptx(
  slide: pptxgen.Slide,
  content: ChartSlideContent,
  title: string,
  subtitle?: string
): void {
  // Title
  slide.addText(title, {
    x: 0.5,
    y: 0.3,
    w: '90%',
    h: 0.5,
    fontSize: 24,
    fontFace: 'Arial',
    color: COLORS.text,
    bold: true,
  });

  // Subtitle
  if (subtitle) {
    slide.addText(subtitle, {
      x: 0.5,
      y: 0.75,
      w: '90%',
      h: 0.3,
      fontSize: 12,
      fontFace: 'Arial',
      color: COLORS.textSecondary,
    });
  }

  // Chart
  const chartData = content.data;
  const chartType = content.chartType;

  try {
    if (chartType === 'bar' || chartType === 'histogram') {
      addBarChartPptx(slide, chartData, chartType === 'histogram');
    } else if (chartType === 'line' || chartType === 'area') {
      addLineChartPptx(slide, chartData);
    } else if (chartType === 'pie' || chartType === 'donut') {
      addPieChartPptx(slide, chartData, chartType === 'donut');
    } else {
      // Fallback to table for unsupported chart types
      addDataTablePptx(slide, chartData);
    }
  } catch {
    // If chart fails, add a placeholder
    slide.addText('Chart visualization', {
      x: 0.5,
      y: 1.5,
      w: '90%',
      h: 3,
      fontSize: 16,
      fontFace: 'Arial',
      color: COLORS.textSecondary,
      align: 'center',
      valign: 'middle',
    });
  }

  // Confidence badge
  slide.addText(`Confidence: ${(content.recommendation.confidence * 100).toFixed(0)}%`, {
    x: 7.5,
    y: 4.8,
    w: 2,
    h: 0.3,
    fontSize: 10,
    fontFace: 'Arial',
    color: COLORS.textSecondary,
    fill: { color: COLORS.cardBackground },
  });
}

/**
 * Add bar chart to PPTX slide
 */
function addBarChartPptx(
  slide: pptxgen.Slide,
  data: Array<Record<string, unknown>>,
  isHistogram: boolean
): void {
  const labels = data.map(d => String(d.name || d.range || d.index || ''));
  const values = data.map(d => Number(d.value || d.count || 0));

  slide.addChart('bar', [
    {
      name: isHistogram ? 'Distribution' : 'Values',
      labels,
      values,
    },
  ], {
    x: 0.5,
    y: 1.2,
    w: 9,
    h: 3.5,
    barDir: 'bar',
    barGapWidthPct: 25,
    chartColors: COLORS.chart,
    showLegend: false,
    showTitle: false,
    catAxisLabelColor: COLORS.textSecondary,
    catAxisLabelFontSize: 10,
    valAxisLabelColor: COLORS.textSecondary,
    valAxisLabelFontSize: 10,
    catGridLine: { style: 'none' },
    valGridLine: { color: '333333', style: 'dash' },
  });
}

/**
 * Add line chart to PPTX slide
 */
function addLineChartPptx(
  slide: pptxgen.Slide,
  data: Array<Record<string, unknown>>
): void {
  const labels = data.map((_, i) => String(i + 1));
  const values = data.map(d => Number(d.value || 0));

  slide.addChart('line', [
    {
      name: 'Trend',
      labels,
      values,
    },
  ], {
    x: 0.5,
    y: 1.2,
    w: 9,
    h: 3.5,
    chartColors: [COLORS.chart[0]],
    showLegend: false,
    showTitle: false,
    lineSmooth: true,
    lineDataSymbol: 'circle',
    lineDataSymbolSize: 6,
    catAxisLabelColor: COLORS.textSecondary,
    catAxisLabelFontSize: 10,
    valAxisLabelColor: COLORS.textSecondary,
    valAxisLabelFontSize: 10,
    catGridLine: { style: 'none' },
    valGridLine: { color: '333333', style: 'dash' },
  });
}

/**
 * Add pie chart to PPTX slide
 */
function addPieChartPptx(
  slide: pptxgen.Slide,
  data: Array<Record<string, unknown>>,
  isDonut: boolean
): void {
  const labels = data.map(d => String(d.name || ''));
  const values = data.map(d => Number(d.value || 0));

  slide.addChart(isDonut ? 'doughnut' : 'pie', [
    {
      name: 'Distribution',
      labels,
      values,
    },
  ], {
    x: 1.5,
    y: 1.2,
    w: 7,
    h: 3.5,
    chartColors: COLORS.chart,
    showLegend: true,
    legendPos: 'r',
    legendColor: COLORS.textSecondary,
    showLabel: true,
    showPercent: true,
    showTitle: false,
    holeSize: isDonut ? 50 : 0,
  });
}

/**
 * Add data table to PPTX slide (fallback)
 */
function addDataTablePptx(
  slide: pptxgen.Slide,
  data: Array<Record<string, unknown>>
): void {
  if (data.length === 0) return;

  const headers = Object.keys(data[0]);
  const rows = data.slice(0, 10).map(row =>
    headers.map(h => ({ text: String(row[h] ?? '') }))
  );

  const tableData: pptxgen.TableRow[] = [
    headers.map(h => ({ text: h })),
    ...rows,
  ];

  slide.addTable(tableData, {
    x: 0.5,
    y: 1.2,
    w: 9,
    h: 3.5,
    fontSize: 10,
    fontFace: 'Arial',
    color: COLORS.text,
    fill: { color: COLORS.cardBackground },
    border: { color: '333333', pt: 1 },
    autoPage: true,
  });
}

/**
 * Add table slide to PPTX
 */
function addTableSlidePptx(
  slide: pptxgen.Slide,
  content: TableSlideContent,
  title: string
): void {
  // Title
  slide.addText(title, {
    x: 0.5,
    y: 0.3,
    w: '90%',
    h: 0.5,
    fontSize: 24,
    fontFace: 'Arial',
    color: COLORS.text,
    bold: true,
  });

  // Table
  const tableData: pptxgen.TableRow[] = [
    content.headers.map(h => ({ text: h })),
    ...content.rows.map(row => row.map(cell => ({ text: String(cell) }))),
  ];

  slide.addTable(tableData, {
    x: 0.5,
    y: 1,
    w: 9,
    h: 4,
    fontSize: 11,
    fontFace: 'Arial',
    color: COLORS.text,
    fill: { color: COLORS.cardBackground },
    border: { color: '333333', pt: 1 },
    autoPage: true,
  });
}

/**
 * Add summary slide to PPTX
 */
function addSummarySlidePptx(slide: pptxgen.Slide, content: SummarySlideContent): void {
  // Title
  slide.addText('Key Insights & Next Steps', {
    x: 0.5,
    y: 0.3,
    w: '90%',
    h: 0.5,
    fontSize: 24,
    fontFace: 'Arial',
    color: COLORS.text,
    bold: true,
  });

  // Insights column
  slide.addText('INSIGHTS', {
    x: 0.5,
    y: 1,
    w: 4,
    h: 0.3,
    fontSize: 12,
    fontFace: 'Arial',
    color: COLORS.textSecondary,
    bold: true,
  });

  content.insights.forEach((insight, index) => {
    slide.addText(`→ ${insight}`, {
      x: 0.5,
      y: 1.4 + index * 0.45,
      w: 4.3,
      h: 0.4,
      fontSize: 11,
      fontFace: 'Arial',
      color: COLORS.text,
      valign: 'top',
    });
  });

  // Next steps column
  slide.addText('NEXT STEPS', {
    x: 5.2,
    y: 1,
    w: 4,
    h: 0.3,
    fontSize: 12,
    fontFace: 'Arial',
    color: COLORS.textSecondary,
    bold: true,
  });

  content.nextSteps.forEach((step, index) => {
    slide.addShape('ellipse', {
      x: 5.2,
      y: 1.4 + index * 0.45,
      w: 0.25,
      h: 0.25,
      fill: { color: COLORS.accent },
    });
    slide.addText(String(index + 1), {
      x: 5.2,
      y: 1.4 + index * 0.45,
      w: 0.25,
      h: 0.25,
      fontSize: 9,
      fontFace: 'Arial',
      color: COLORS.text,
      align: 'center',
      valign: 'middle',
    });
    slide.addText(step, {
      x: 5.55,
      y: 1.4 + index * 0.45,
      w: 4,
      h: 0.4,
      fontSize: 11,
      fontFace: 'Arial',
      color: COLORS.text,
      valign: 'top',
    });
  });

  // Patterns
  if (content.patterns.length > 0) {
    slide.addShape('rect', {
      x: 0.5,
      y: 4.2,
      w: 9,
      h: 0.7,
      fill: { color: COLORS.cardBackground },
    });

    slide.addText('DETECTED PATTERNS', {
      x: 0.6,
      y: 4.25,
      w: 2,
      h: 0.25,
      fontSize: 9,
      fontFace: 'Arial',
      color: COLORS.textSecondary,
    });

    const patternText = content.patterns
      .map(p => `${p.field}: ${p.pattern} (${(p.matchRate * 100).toFixed(0)}%)`)
      .join('  •  ');

    slide.addText(patternText, {
      x: 0.6,
      y: 4.55,
      w: 8.8,
      h: 0.3,
      fontSize: 10,
      fontFace: 'Arial',
      color: COLORS.textSecondary,
    });
  }
}

// --- PDF Export ---

/**
 * Export slides to PDF format
 */
export async function exportToPdf(
  slides: SlideData[],
  options: ExportOptions = {}
): Promise<ExportResult> {
  const {
    filename = 'presentation',
    author = 'Web Scraper Pro',
    title = 'Data Analysis Report',
  } = options;

  try {
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'a4',
    });

    // Set document properties
    pdf.setProperties({
      title,
      author,
      subject: 'Data Analysis Report',
      creator: 'Web Scraper Pro',
    });

    // Generate each slide
    slides.forEach((slideData, index) => {
      if (index > 0) {
        pdf.addPage();
      }

      // Background
      pdf.setFillColor(22, 33, 62); // #16213e
      pdf.rect(0, 0, 297, 210, 'F');

      switch (slideData.type) {
        case 'title':
          addTitleSlidePdf(pdf, slideData.content as TitleSlideContent);
          break;
        case 'metrics':
          addMetricsSlidePdf(pdf, slideData.content as MetricsSlideContent);
          break;
        case 'chart':
          addChartSlidePdf(pdf, slideData.content as ChartSlideContent, slideData.title, slideData.subtitle);
          break;
        case 'table':
          addTableSlidePdf(pdf, slideData.content as TableSlideContent, slideData.title);
          break;
        case 'summary':
          addSummarySlidePdf(pdf, slideData.content as SummarySlideContent);
          break;
      }

      // Footer
      pdf.setFontSize(8);
      pdf.setTextColor(136, 136, 136);
      pdf.text('Generated by Web Scraper Pro', 10, 200);
      pdf.text(`${index + 1} / ${slides.length}`, 280, 200, { align: 'right' });
    });

    // Save the file
    const finalFilename = `${filename}.pdf`;
    pdf.save(finalFilename);

    return {
      success: true,
      filename: finalFilename,
      format: 'pdf',
    };
  } catch (error) {
    return {
      success: false,
      filename: '',
      format: 'pdf',
      error: error instanceof Error ? error.message : 'Unknown error during PDF export',
    };
  }
}

/**
 * Add title slide to PDF
 */
function addTitleSlidePdf(pdf: jsPDF, content: TitleSlideContent): void {
  // Main title
  pdf.setFontSize(36);
  pdf.setTextColor(102, 126, 234); // #667eea
  pdf.text(content.mainTitle, 148.5, 80, { align: 'center' });

  // Subtitle
  pdf.setFontSize(16);
  pdf.setTextColor(170, 170, 170);
  pdf.text(content.subtitle, 148.5, 100, { align: 'center' });

  // Date and record count
  pdf.setFontSize(12);
  pdf.setTextColor(136, 136, 136);
  pdf.text(`${content.date}  |  ${content.recordCount.toLocaleString()} records`, 148.5, 130, { align: 'center' });
}

/**
 * Add metrics slide to PDF
 */
function addMetricsSlidePdf(pdf: jsPDF, content: MetricsSlideContent): void {
  // Title
  pdf.setFontSize(24);
  pdf.setTextColor(238, 238, 238);
  pdf.text('Data Overview', 20, 25);

  const metrics = content.metrics;
  const cardWidth = 50;
  const cardHeight = 35;
  const startX = (297 - (metrics.length * cardWidth + (metrics.length - 1) * 10)) / 2;
  const y = 60;

  metrics.forEach((metric, index) => {
    const x = startX + index * (cardWidth + 10);

    const statusColor = metric.status === 'good' ? [34, 197, 94] :
                       metric.status === 'warning' ? [234, 179, 8] :
                       metric.status === 'critical' ? [239, 68, 68] : [238, 238, 238];

    // Card background
    pdf.setFillColor(30, 42, 74);
    pdf.roundedRect(x, y, cardWidth, cardHeight, 3, 3, 'F');

    // Left border
    pdf.setFillColor(statusColor[0], statusColor[1], statusColor[2]);
    pdf.rect(x, y, 2, cardHeight, 'F');

    // Value
    pdf.setFontSize(20);
    pdf.setTextColor(statusColor[0], statusColor[1], statusColor[2]);
    pdf.text(String(metric.value), x + cardWidth / 2, y + 15, { align: 'center' });

    // Label
    pdf.setFontSize(9);
    pdf.setTextColor(136, 136, 136);
    pdf.text(metric.label, x + cardWidth / 2, y + 27, { align: 'center' });
  });
}

/**
 * Add chart slide to PDF
 */
function addChartSlidePdf(
  pdf: jsPDF,
  content: ChartSlideContent,
  title: string,
  subtitle?: string
): void {
  // Title
  pdf.setFontSize(20);
  pdf.setTextColor(238, 238, 238);
  pdf.text(title, 20, 25);

  // Subtitle
  if (subtitle) {
    pdf.setFontSize(10);
    pdf.setTextColor(136, 136, 136);
    pdf.text(subtitle, 20, 35);
  }

  // Chart placeholder (PDF can't render interactive charts)
  pdf.setFillColor(30, 42, 74);
  pdf.roundedRect(20, 45, 257, 130, 3, 3, 'F');

  // Add data summary instead of actual chart
  const data = content.data;
  if (data.length > 0) {
    pdf.setFontSize(12);
    pdf.setTextColor(170, 170, 170);
    pdf.text(`Chart Type: ${content.chartType}`, 30, 60);
    pdf.text(`Data Points: ${data.length}`, 30, 72);

    // Show top values
    const topValues = data.slice(0, 8);
    pdf.setFontSize(10);
    topValues.forEach((item, index) => {
      const label = String(item.name || item.range || item.index || index);
      const value = item.value || item.count || 0;
      pdf.text(`${label}: ${value}`, 30, 90 + index * 10);
    });
  }

  // Confidence badge
  pdf.setFontSize(9);
  pdf.setTextColor(136, 136, 136);
  pdf.text(`Confidence: ${(content.recommendation.confidence * 100).toFixed(0)}%`, 250, 180, { align: 'right' });
}

/**
 * Add table slide to PDF
 */
function addTableSlidePdf(pdf: jsPDF, content: TableSlideContent, title: string): void {
  // Title
  pdf.setFontSize(20);
  pdf.setTextColor(238, 238, 238);
  pdf.text(title, 20, 25);

  // Table
  const startY = 40;
  const rowHeight = 10;
  const colWidth = (297 - 40) / content.headers.length;

  // Headers
  pdf.setFillColor(30, 42, 74);
  pdf.rect(20, startY, 257, rowHeight, 'F');
  pdf.setFontSize(10);
  pdf.setTextColor(170, 170, 170);
  content.headers.forEach((header, index) => {
    pdf.text(header, 22 + index * colWidth, startY + 7);
  });

  // Rows
  pdf.setTextColor(221, 221, 221);
  const maxRows = Math.min(content.rows.length, 12);
  content.rows.slice(0, maxRows).forEach((row, rowIndex) => {
    const y = startY + (rowIndex + 1) * rowHeight;

    // Alternating background
    if (rowIndex % 2 === 0) {
      pdf.setFillColor(25, 35, 55);
      pdf.rect(20, y, 257, rowHeight, 'F');
    }

    row.forEach((cell, cellIndex) => {
      pdf.text(String(cell).substring(0, 30), 22 + cellIndex * colWidth, y + 7);
    });
  });
}

/**
 * Add summary slide to PDF
 */
function addSummarySlidePdf(pdf: jsPDF, content: SummarySlideContent): void {
  // Title
  pdf.setFontSize(20);
  pdf.setTextColor(238, 238, 238);
  pdf.text('Key Insights & Next Steps', 20, 25);

  // Insights column
  pdf.setFontSize(11);
  pdf.setTextColor(136, 136, 136);
  pdf.text('INSIGHTS', 20, 45);

  pdf.setFontSize(10);
  pdf.setTextColor(204, 204, 204);
  content.insights.slice(0, 6).forEach((insight, index) => {
    pdf.text(`→ ${insight.substring(0, 60)}`, 20, 55 + index * 12);
  });

  // Next steps column
  pdf.setFontSize(11);
  pdf.setTextColor(136, 136, 136);
  pdf.text('NEXT STEPS', 155, 45);

  pdf.setFontSize(10);
  pdf.setTextColor(204, 204, 204);
  content.nextSteps.slice(0, 4).forEach((step, index) => {
    // Number circle
    pdf.setFillColor(102, 126, 234);
    pdf.circle(159, 53 + index * 12, 3, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(8);
    pdf.text(String(index + 1), 159, 55 + index * 12, { align: 'center' });

    // Step text
    pdf.setFontSize(10);
    pdf.setTextColor(204, 204, 204);
    pdf.text(step.substring(0, 50), 165, 55 + index * 12);
  });

  // Patterns
  if (content.patterns.length > 0) {
    pdf.setFillColor(30, 42, 74);
    pdf.roundedRect(20, 160, 257, 25, 3, 3, 'F');

    pdf.setFontSize(9);
    pdf.setTextColor(136, 136, 136);
    pdf.text('DETECTED PATTERNS', 25, 170);

    const patternText = content.patterns
      .slice(0, 4)
      .map(p => `${p.field}: ${p.pattern} (${(p.matchRate * 100).toFixed(0)}%)`)
      .join('  •  ');

    pdf.setTextColor(170, 170, 170);
    pdf.text(patternText, 25, 180);
  }
}

